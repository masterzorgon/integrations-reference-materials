import { IxFromHex } from "./utils/instructions.js";
import { decodeString } from "./utils/string.js";
import axios from "axios";
import bs58 from "bs58";
export class CrossbarClient {
    crossbarUrl;
    verbose;
    // feed hash -> crossbar response
    feedCache = new Map();
    static default(verbose) {
        return new CrossbarClient("https://crossbar.switchboard.xyz", verbose);
    }
    constructor(crossbarUrl, verbose) {
        this.crossbarUrl = new URL(crossbarUrl).origin;
        this.verbose = !!verbose;
    }
    /**
     * GET /fetch/:feedHash
     * Fetch data from the crossbar using the provided feedHash
     * @param {string} feedHash - The hash of the feed to fetch data for
     * @returns {Promise<{feedHash: string; queueHex: string; jobs: IOracleJob[];}} - The data fetched from the crossbar
     */
    async fetch(feedHash) {
        try {
            // Check if the feedHash is already in the cache
            const cached = this.feedCache.get(feedHash);
            if (cached)
                return cached;
            // Fetch the data from the crossbar
            const response = await axios
                .get(`${this.crossbarUrl}/fetch/${feedHash}`)
                .then((resp) => resp.data);
            // Cache the response on the crossbar instance
            this.feedCache.set(feedHash, response);
            return response;
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            // If response is outside of the 200 range, log the status and throw an error.
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetch status: ${response.status}`);
        }
    }
    /**
     * POST /store
     * Store oracle jobs on the crossbar, associated with a queue address
     * @param {string} queueAddress - The address of the queue
     * @param {IOracleJob[]} jobs - The oracle jobs to store
     * @returns {Promise<{ cid: string; feedHash: string; queueHex: string }>} - The stored data information
     */
    async store(queueAddress, jobs) {
        try {
            // Try to decode the queueAddress to a Buffer so that we can send it in the expected format,
            // base58, to the Crossbar node.
            const queue = decodeString(queueAddress);
            if (!queue)
                throw new Error(`Unable to parse queue: ${queueAddress}`);
            return await axios
                .post(`${this.crossbarUrl}/store`, { queue: bs58.encode(queue), jobs }, { headers: { "Content-Type": "application/json" } })
                .then((resp) => {
                if (resp.status === 200)
                    return resp.data;
                throw new Error(`Bad Crossbar store response: ${resp.status}`);
            });
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar store response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/:feedHashes
     * Simulate fetching feed results from the crossbar using feed hashes
     * @param {string[]} feedHashes - The hashes of the feeds to simulate
     * @returns {Promise<{ feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    async simulateFeeds(feedHashes) {
        try {
            if (!feedHashes || feedHashes.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = feedHashes.join(",");
            return await axios
                .get(`${this.crossbarUrl}/simulate/${feedsParam}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateFeed response: ${response.status}`);
        }
    }
    /**
     * GET /updates/solana/:network/:feedpubkeys
     * Fetch updates for Solana network feeds from the crossbar
     * @param {string} network - The Solana network to fetch updates for
     * @param {string[]} feedpubkeys - The public keys of the feeds to fetch updates for
     * @param {number} [numSignatures] - The number of signatures to fetch (optional)
     * @returns {Promise<{ success: boolean; pullIx: TransactionInstruction; responses: { oracle: string; result: number | null; errors: string }[]; lookupTables: string[] }[]>} - The updates for the specified feeds
     */
    async fetchSolanaUpdates(network, feedpubkeys, numSignatures) {
        try {
            if (!network)
                throw new Error("Network is required");
            if (!feedpubkeys || feedpubkeys.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = feedpubkeys.join(",");
            const response = await axios
                .get(`${this.crossbarUrl}/updates/solana/${network}/${feedsParam}`, {
                params: { numSignatures },
            })
                .then((resp) => resp.data);
            // Convert pullIx from hex to TransactionInstruction using IxFromHex
            const updates = response.map((update) => ({
                ...update,
                pullIx: IxFromHex(update.pullIx),
            }));
            return updates;
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchSolanaUpdates response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/solana/:network/:feedpubkeys
     * Simulate fetching Solana feed results from the crossbar
     * @param {string} network - The Solana network to simulate
     * @param {string[]} feedpubkeys - The public keys of the feeds to simulate
     * @returns {Promise<{ feed: string; feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    async simulateSolanaFeeds(network, feedpubkeys) {
        try {
            if (!network)
                throw new Error("Network is required");
            if (!feedpubkeys || feedpubkeys.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = feedpubkeys.join(",");
            return await axios
                .get(`${this.crossbarUrl}/simulate/solana/${network}/${feedsParam}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateSolanaFeeds response: ${response.status}`);
        }
    }
    /**
     * GET /updates/evm/:chainId/:aggregatorIds
     * Fetch updates for EVM network feeds from the crossbar
     * @param param0 - The chain ID and aggregator IDs to fetch updates for
     * @returns Promise<{ results: EVMResult[]; encoded: string[] }> - The updates for the specified feeds
     */
    async fetchEVMResults({ chainId, aggregatorIds, }) {
        try {
            if (!chainId)
                throw new Error("Chain ID is required");
            if (!aggregatorIds || aggregatorIds.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = aggregatorIds.join(",");
            return await axios
                .get(`${this.crossbarUrl}/updates/evm/${chainId}/${feedsParam}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchEVMUpdates response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/evm/:network/:aggregatorIds
     * Simulate fetching Solana feed results from the crossbar
     * @param {string} network - The Solana network to simulate
     * @param {string[]} aggregatorIds - The public keys of the feeds to simulate
     * @returns {Promise<{ feed: string; feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    async simulateEVMFeeds(network, aggregatorIds) {
        try {
            if (!network)
                throw new Error("Network is required");
            if (!aggregatorIds || aggregatorIds.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = aggregatorIds.join(",");
            return await axios
                .get(`${this.crossbarUrl}/simulate/evm/${network}/${feedsParam}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateEVMFeeds response: ${response.status}`);
        }
    }
    /**
     * GET /randomness/evm/:chainId/:randomnessId
     * @param param0 - The chain ID and randomness ID to resolve
     */
    async resolveEVMRandomness({ chainId, randomnessId, }) {
        try {
            return await axios
                .get(`${this.crossbarUrl}/randomness/evm/${chainId}/${randomnessId}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar resolveEVMRandomness response: ${response.status}`);
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3Jvc3NiYXJDbGllbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvQ3Jvc3NiYXJDbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3BELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUlqRCxPQUFPLEtBQUssTUFBTSxPQUFPLENBQUM7QUFDMUIsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBMEV4QixNQUFNLE9BQU8sY0FBYztJQUNoQixXQUFXLENBQVM7SUFDcEIsT0FBTyxDQUFVO0lBRTFCLGlDQUFpQztJQUN4QixTQUFTLEdBQXVDLElBQUksR0FBRyxFQUFFLENBQUM7SUFFbkUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFpQjtRQUM5QixPQUFPLElBQUksY0FBYyxDQUFDLGtDQUFrQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFRCxZQUFZLFdBQW1CLEVBQUUsT0FBaUI7UUFDaEQsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFDL0MsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEtBQUssQ0FBQyxLQUFLLENBQUMsUUFBZ0I7UUFLMUIsSUFBSSxDQUFDO1lBQ0gsZ0RBQWdEO1lBQ2hELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzVDLElBQUksTUFBTTtnQkFBRSxPQUFPLE1BQU0sQ0FBQztZQUUxQixtQ0FBbUM7WUFDbkMsTUFBTSxRQUFRLEdBQUcsTUFBTSxLQUFLO2lCQUN6QixHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxVQUFVLFFBQVEsRUFBRSxDQUFDO2lCQUM1QyxJ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QUFFLENBQUMsQ0FBQztZQUN4RSxNQUFNLElBQUksS0FBSyxDQUNiLCtDQUErQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQ2pFLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSXhGcm9tSGV4IH0gZnJvbSBcIi4vdXRpbHMvaW5zdHJ1Y3Rpb25zLmpzXCI7XG5pbXBvcnQgeyBkZWNvZGVTdHJpbmcgfSBmcm9tIFwiLi91dGlscy9zdHJpbmcuanNcIjtcbmltcG9ydCB0eXBlIHsgSU9yYWNsZUpvYiwgT3JhY2xlSm9iIH0gZnJvbSBcIi4vcHJvdG9zLmpzXCI7XG5cbmltcG9ydCB0eXBlIHsgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB9IGZyb20gXCJAc29sYW5hL3dlYjMuanNcIjtcbmltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCBiczU4IGZyb20gXCJiczU4XCI7XG5cbi8qKlxuICogIFRoZSByZXNwb25zZSBmcm9tIHRoZSBnYXRld2F5IGFmdGVyIGZldGNoaW5nIHNpZ25hdHVyZXMuXG4gKiAgVmFyaWFibGVzIGFyZSBzbmFrZV9jYXNlIGZvciBzZXJpYWxpemF0aW9uLlxuICovXG5leHBvcnQgdHlwZSBGZWVkRXZhbFJlc3BvbnNlID0ge1xuICAvKipcbiAgICogIEhleCBlbmNvZGVkIG9yYWNsZSBwdWJrZXlcbiAgICovXG4gIG9yYWNsZV9wdWJrZXk6IHN0cmluZztcbiAgLyoqXG4gICAqICBIZXggZW5jb2RlZCBxdWV1ZSBwdWJrZXlcbiAgICovXG4gIHF1ZXVlX3B1YmtleTogc3RyaW5nO1xuICAvKipcbiAgICogIEhleCBlbmNvZGVkIG9yYWNsZSBzaWduaW5nIHB1YmtleVxuICAgKi9cbiAgb3JhY2xlX3NpZ25pbmdfcHVia2V5OiBzdHJpbmc7XG4gIC8qKlxuICAgKiAgSGV4IGVuY29kZWQgZmVlZCBpZFxuICAgKi9cbiAgZmVlZF9oYXNoOiBzdHJpbmc7XG4gIC8qKlxuICAgKiAgSGV4IGVuY29kZWQgYmxvY2toYXNoL3Nsb3RoYXNoIHRoZSByZXNwb25zZSB3YXMgc2lnbmVkIHdpdGguXG4gICAqL1xuICByZWNlbnRfaGFzaDogc3RyaW5nO1xuICAvKipcbiAgICogIEVycm9ycyBlbmNvdW50ZXJlZCB3aGlsZSBmZXRjaGluZyBmZWVkIHZhbHVlXG4gICAqL1xuICBmYWlsdXJlX2Vycm9yOiBzdHJpbmc7XG4gIC8qKlxuICAgKiAgRmVlZCB2YWx1ZXMgZGVyaXZlZFxuICAgKi9cbiAgc3VjY2Vzc192YWx1ZTogc3RyaW5nO1xuICAvKipcbiAgICogIFNpZ25lZCBtZXNzYWdlIG9mIHRoZSByZXN1bHQgYW5kIGJsb2NraGFzaFxuICAgKi9cbiAgbXNnOiBzdHJpbmc7XG4gIC8qKlxuICAgKiAgT3JhY2xlIHNpZ25hdHVyZSBvZiB0aGUgcmVzdWx0IGFuZCBibG9ja2hhc2hcbiAgICpcbiAgICogIFNoYTI1NihzdWNjZXNzX2ZlZWRfaGFzaGVzIHx8IHJlc3VsdHMgfHwgc2xvdGhhc2gpXG4gICAqL1xuICBzaWduYXR1cmU6IHN0cmluZztcbiAgcmVjb3ZlcnlfaWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogIElmIHRoZSBmZWVkIGZldGNoIGZhaWxlZCwgZ2V0IG90aGVyIHJlY2VudCBzdWNjZXNzZXNcbiAgICovXG4gIHJlY2VudF9zdWNjZXNzZXNfaWZfZmFpbGVkOiBBcnJheTxGZWVkRXZhbFJlc3BvbnNlPjtcblxuICAvKipcbiAgICogVGltZXN0YW1wIG1hcmtpbmcgd2hlbiB0aGUgcmVzdWx0IHdhcyBmZXRjaGVkXG4gICAqL1xuICB0aW1lc3RhbXA/OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBDcm9zc2JhckZldGNoUmVzcG9uc2UgPSB7XG4gIGZlZWRIYXNoOiBzdHJpbmc7XG4gIHF1ZXVlSGV4OiBzdHJpbmc7XG4gIGpvYnM6IElPcmFjbGVKb2JbXTtcbn07XG5cbi8qKlxuICogVGhlIHJlc3BvbnNlIGZyb20gdGhlIGdhdGV3YXkgYWZ0ZXIgZmV0Y2hpbmcgc2lnbmF0dXJlcy5cbiAqL1xuZXhwb3J0IHR5cGUgRVZNUmVzdWx0ID0gRmVlZEV2YWxSZXNwb25zZSAmIHtcbiAgLyoqXG4gICAqICBUaGUgcmVzdWx0IG9mIHRoZSBmZWVkIGV2YWx1YXRpb25cbiAgICovXG4gIHJlc3VsdDogbnVtYmVyO1xufTtcblxuZXhwb3J0IGNsYXNzIENyb3NzYmFyQ2xpZW50IHtcbiAgcmVhZG9ubHkgY3Jvc3NiYXJVcmw6IHN0cmluZztcbiAgcmVhZG9ubHkgdmVyYm9zZTogYm9vbGVhbjtcblxuICAvLyBmZWVkIGhhc2ggLT4gY3Jvc3NiYXIgcmVzcG9uc2VcbiAgcmVhZG9ubHkgZmVlZENhY2hlOiBNYXA8c3RyaW5nLCBDcm9zc2JhckZldGNoUmVzcG9uc2U+ID0gbmV3IE1hcCgpO1xuXG4gIHN0YXRpYyBkZWZhdWx0KHZlcmJvc2U/OiBib29sZWFuKSB7XG4gICAgcmV0dXJuIG5ldyBDcm9zc2JhckNsaWVudChcImh0dHBzOi8vY3Jvc3NiYXIuc3dpdGNoYm9hcmQueHl6XCIsIHZlcmJvc2UpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoY3Jvc3NiYXJVcmw6IHN0cmluZywgdmVyYm9zZT86IGJvb2xlYW4pIHtcbiAgICB0aGlzLmNyb3NzYmFyVXJsID0gbmV3IFVSTChjcm9zc2JhclVybCkub3JpZ2luO1xuICAgIHRoaXMudmVyYm9zZSA9ICEhdmVyYm9zZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHRVQgL2ZldGNoLzpmZWVkSGFzaFxuICAgKiBGZXRjaCBkYXRhIGZyb20gdGhlIGNyb3NzYmFyIHVzaW5nIHRoZSBwcm92aWRlZCBmZWVkSGFzaFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmVlZEhhc2ggLSBUaGUgaGFzaCBvZiB0aGUgZmVlZCB0byBmZXRjaCBkYXRhIGZvclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7ZmVlZEhhc2g6IHN0cmluZzsgcXVldWVIZXg6IHN0cmluZzsgam9iczogSU9yYWNsZUpvYltdO319IC0gVGhlIGRhdGEgZmV0Y2hlZCBmcm9tIHRoZSBjcm9zc2JhclxuICAgKi9cbiAgYXN5bmMgZmV0Y2goZmVlZEhhc2g6IHN0cmluZyk6IFByb21pc2U8e1xuICAgIGZlZWRIYXNoOiBzdHJpbmc7XG4gICAgcXVldWVIZXg6IHN0cmluZztcbiAgICBqb2JzOiBJT3JhY2xlSm9iW107XG4gIH0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZlZWRIYXNoIGlzIGFscmVhZHkgaW4gdGhlIGNhY2hlXG4gICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmZlZWRDYWNoZS5nZXQoZmVlZEhhc2gpO1xuICAgICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcblxuICAgICAgLy8gRmV0Y2ggdGhlIGRhdGEgZnJvbSB0aGUgY3Jvc3NiYXJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3NcbiAgICAgICAgLmdldChgJHt0aGlzLmNyb3NzYmFyVXJsfS9mZXRjaC8ke2ZlZWRIYXNofWApXG4gICAgICAgIC50aGVuKChyZXNwKSA9PiByZXNwLmRhdGEpO1xuXG4gICAgICAvLyBDYWNoZSB0aGUgcmVzcG9uc2Ugb24gdGhlIGNyb3NzYmFyIGluc3RhbmNlXG4gICAgICB0aGlzLmZlZWRDYWNoZS5zZXQoZmVlZEhhc2gsIHJlc3BvbnNlKTtcblxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFheGlvcy5pc0F4aW9zRXJyb3IoZXJyKSkgdGhyb3cgZXJyO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGVyci5yZXNwb25zZTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHRocm93IGVycjtcblxuICAgICAgLy8gSWYgcmVzcG9uc2UgaXMgb3V0c2lkZSBvZiB0aGUgMjAwIHJhbmdlLCBsb2cgdGhlIHN0YXR1cyBhbmQgdGhyb3cgYW4gZXJyb3IuXG4gICAgICBpZiAodGhpcy52ZXJib3NlKSBjb25zb2xlLmVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2UuZGF0YX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIENyb3NzYmFyIGZldGNoIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBPU1QgL3N0b3JlXG4gICAqIFN0b3JlIG9yYWNsZSBqb2JzIG9uIHRoZSBjcm9zc2JhciwgYXNzb2NpYXRlZCB3aXRoIGEgcXVldWUgYWRkcmVzc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVldWVBZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHF1ZXVlXG4gICAqIEBwYXJhbSB7SU9yYWNsZUpvYltdfSBqb2JzIC0gVGhlIG9yYWNsZSBqb2JzIHRvIHN0b3JlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgY2lkOiBzdHJpbmc7IGZlZWRIYXNoOiBzdHJpbmc7IHF1ZXVlSGV4OiBzdHJpbmcgfT59IC0gVGhlIHN0b3JlZCBkYXRhIGluZm9ybWF0aW9uXG4gICAqL1xuICBhc3luYyBzdG9yZShcbiAgICBxdWV1ZUFkZHJlc3M6IHN0cmluZyxcbiAgICBqb2JzOiBJT3JhY2xlSm9iW11cbiAgKTogUHJvbWlzZTx7IGNpZDogc3RyaW5nOyBmZWVkSGFzaDogc3RyaW5nOyBxdWV1ZUhleDogc3RyaW5nIH0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVHJ5IHRvIGRlY29kZSB0aGUgcXVldWVBZGRyZXNzIHRvIGEgQnVmZmVyIHNvIHRoYXQgd2UgY2FuIHNlbmQgaXQgaW4gdGhlIGV4cGVjdGVkIGZvcm1hdCxcbiAgICAgIC8vIGJhc2U1OCwgdG8gdGhlIENyb3NzYmFyIG5vZGUuXG4gICAgICBjb25zdCBxdWV1ZSA9IGRlY29kZVN0cmluZyhxdWV1ZUFkZHJlc3MpO1xuICAgICAgaWYgKCFxdWV1ZSkgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcGFyc2UgcXVldWU6ICR7cXVldWVBZGRyZXNzfWApO1xuXG4gICAgICByZXR1cm4gYXdhaXQgYXhpb3NcbiAgICAgICAgLnBvc3QoXG4gICAgICAgICAgYCR7dGhpcy5jcm9zc2JhclVybH0vc3RvcmVgLFxuICAgICAgICAgIHsgcXVldWU6IGJzNTguZW5jb2RlKHF1ZXVlKSwgam9icyB9LFxuICAgICAgICAgIHsgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9IH1cbiAgICAgICAgKVxuICAgICAgICAudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgIGlmIChyZXNwLnN0YXR1cyA9PT0gMjAwKSByZXR1cm4gcmVzcC5kYXRhO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIENyb3NzYmFyIHN0b3JlIHJlc3BvbnNlOiAke3Jlc3Auc3RhdHVzfWApO1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghYXhpb3MuaXNBeGlvc0Vycm9yKGVycikpIHRocm93IGVycjtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBlcnIucmVzcG9uc2U7XG4gICAgICBpZiAoIXJlc3BvbnNlKSB0aHJvdyBlcnI7XG5cbiAgICAgIGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUuZXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5kYXRhfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWQgQ3Jvc3NiYXIgc3RvcmUgcmVzcG9uc2U6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHRVQgL3NpbXVsYXRlLzpmZWVkSGFzaGVzXG4gICAqIFNpbXVsYXRlIGZldGNoaW5nIGZlZWQgcmVzdWx0cyBmcm9tIHRoZSBjcm9zc2JhciB1c2luZyBmZWVkIGhhc2hlc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmZWVkSGFzaGVzIC0gVGhlIGhhc2hlcyBvZiB0aGUgZmVlZHMgdG8gc2ltdWxhdGVcbiAgICogQHJldHVybnMge1Byb21pc2U8eyBmZWVkSGFzaDogc3RyaW5nOyByZXN1bHRzOiBudW1iZXJbXSB9W10+fSAtIFRoZSBzaW11bGF0ZWQgZmVlZCByZXN1bHRzXG4gICAqL1xuICBhc3luYyBzaW11bGF0ZUZlZWRzKFxuICAgIGZlZWRIYXNoZXM6IHN0cmluZ1tdXG4gICk6IFByb21pc2U8eyBmZWVkSGFzaDogc3RyaW5nOyByZXN1bHRzOiBudW1iZXJbXSB9W10+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFmZWVkSGFzaGVzIHx8IGZlZWRIYXNoZXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgZmVlZCBpcyByZXF1aXJlZFwiKTtcblxuICAgICAgY29uc3QgZmVlZHNQYXJhbSA9IGZlZWRIYXNoZXMuam9pbihcIixcIik7XG4gICAgICByZXR1cm4gYXdhaXQgYXhpb3NcbiAgICAgICAgLmdldChgJHt0aGlzLmNyb3NzYmFyVXJsfS9zaW11bGF0ZS8ke2ZlZWRzUGFyYW19YClcbiAgICAgICAgLnRoZW4oKHJlc3ApID0+IHJlc3AuZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWF4aW9zLmlzQXhpb3NFcnJvcihlcnIpKSB0aHJvdyBlcnI7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyLnJlc3BvbnNlO1xuICAgICAgaWYgKCFyZXNwb25zZSkgdGhyb3cgZXJyO1xuXG4gICAgICBpZiAodGhpcy52ZXJib3NlKSBjb25zb2xlLmVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2UuZGF0YX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIENyb3NzYmFyIHNpbXVsYXRlRmVlZCByZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdFVCAvdXBkYXRlcy9zb2xhbmEvOm5ldHdvcmsvOmZlZWRwdWJrZXlzXG4gICAqIEZldGNoIHVwZGF0ZXMgZm9yIFNvbGFuYSBuZXR3b3JrIGZlZWRzIGZyb20gdGhlIGNyb3NzYmFyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gVGhlIFNvbGFuYSBuZXR3b3JrIHRvIGZldGNoIHVwZGF0ZXMgZm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGZlZWRwdWJrZXlzIC0gVGhlIHB1YmxpYyBrZXlzIG9mIHRoZSBmZWVkcyB0byBmZXRjaCB1cGRhdGVzIGZvclxuICAgKiBAcGFyYW0ge251bWJlcn0gW251bVNpZ25hdHVyZXNdIC0gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHRvIGZldGNoIChvcHRpb25hbClcbiAgICogQHJldHVybnMge1Byb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBwdWxsSXg6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb247IHJlc3BvbnNlczogeyBvcmFjbGU6IHN0cmluZzsgcmVzdWx0OiBudW1iZXIgfCBudWxsOyBlcnJvcnM6IHN0cmluZyB9W107IGxvb2t1cFRhYmxlczogc3RyaW5nW10gfVtdPn0gLSBUaGUgdXBkYXRlcyBmb3IgdGhlIHNwZWNpZmllZCBmZWVkc1xuICAgKi9cbiAgYXN5bmMgZmV0Y2hTb2xhbmFVcGRhdGVzKFxuICAgIG5ldHdvcms6IHN0cmluZyxcbiAgICBmZWVkcHVia2V5czogc3RyaW5nW10sXG4gICAgbnVtU2lnbmF0dXJlcz86IG51bWJlclxuICApOiBQcm9taXNlPFxuICAgIHtcbiAgICAgIHN1Y2Nlc3M6IGJvb2xlYW47XG4gICAgICBwdWxsSXg6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb247XG4gICAgICByZXNwb25zZXM6IHsgb3JhY2xlOiBzdHJpbmc7IHJlc3VsdDogbnVtYmVyIHwgbnVsbDsgZXJyb3JzOiBzdHJpbmcgfVtdO1xuICAgICAgbG9va3VwVGFibGVzOiBzdHJpbmdbXTtcbiAgICB9W11cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghbmV0d29yaykgdGhyb3cgbmV3IEVycm9yKFwiTmV0d29yayBpcyByZXF1aXJlZFwiKTtcbiAgICAgIGlmICghZmVlZHB1YmtleXMgfHwgZmVlZHB1YmtleXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgZmVlZCBpcyByZXF1aXJlZFwiKTtcblxuICAgICAgY29uc3QgZmVlZHNQYXJhbSA9IGZlZWRwdWJrZXlzLmpvaW4oXCIsXCIpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvc1xuICAgICAgICAuZ2V0KGAke3RoaXMuY3Jvc3NiYXJVcmx9L3VwZGF0ZXMvc29sYW5hLyR7bmV0d29ya30vJHtmZWVkc1BhcmFtfWAsIHtcbiAgICAgICAgICBwYXJhbXM6IHsgbnVtU2lnbmF0dXJlcyB9LFxuICAgICAgICB9KVxuICAgICAgICAudGhlbigocmVzcCkgPT4gcmVzcC5kYXRhKTtcblxuICAgICAgLy8gQ29udmVydCBwdWxsSXggZnJvbSBoZXggdG8gVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB1c2luZyBJeEZyb21IZXhcbiAgICAgIGNvbnN0IHVwZGF0ZXMgPSByZXNwb25zZS5tYXAoKHVwZGF0ZTogYW55KSA9PiAoe1xuICAgICAgICAuLi51cGRhdGUsXG4gICAgICAgIHB1bGxJeDogSXhGcm9tSGV4KHVwZGF0ZS5wdWxsSXgpLFxuICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gdXBkYXRlcztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghYXhpb3MuaXNBeGlvc0Vycm9yKGVycikpIHRocm93IGVycjtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBlcnIucmVzcG9uc2U7XG4gICAgICBpZiAoIXJlc3BvbnNlKSB0aHJvdyBlcnI7XG5cbiAgICAgIGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUuZXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5kYXRhfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQmFkIENyb3NzYmFyIGZldGNoU29sYW5hVXBkYXRlcyByZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR0VUIC9zaW11bGF0ZS9zb2xhbmEvOm5ldHdvcmsvOmZlZWRwdWJrZXlzXG4gICAqIFNpbXVsYXRlIGZldGNoaW5nIFNvbGFuYSBmZWVkIHJlc3VsdHMgZnJvbSB0aGUgY3Jvc3NiYXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBUaGUgU29sYW5hIG5ldHdvcmsgdG8gc2ltdWxhdGVcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmVlZHB1YmtleXMgLSBUaGUgcHVibGljIGtleXMgb2YgdGhlIGZlZWRzIHRvIHNpbXVsYXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgZmVlZDogc3RyaW5nOyBmZWVkSGFzaDogc3RyaW5nOyByZXN1bHRzOiBudW1iZXJbXSB9W10+fSAtIFRoZSBzaW11bGF0ZWQgZmVlZCByZXN1bHRzXG4gICAqL1xuICBhc3luYyBzaW11bGF0ZVNvbGFuYUZlZWRzKFxuICAgIG5ldHdvcms6IHN0cmluZyxcbiAgICBmZWVkcHVia2V5czogc3RyaW5nW11cbiAgKTogUHJvbWlzZTx7IGZlZWQ6IHN0cmluZzsgZmVlZEhhc2g6IHN0cmluZzsgcmVzdWx0czogbnVtYmVyW10gfVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghbmV0d29yaykgdGhyb3cgbmV3IEVycm9yKFwiTmV0d29yayBpcyByZXF1aXJlZFwiKTtcbiAgICAgIGlmICghZmVlZHB1YmtleXMgfHwgZmVlZHB1YmtleXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgZmVlZCBpcyByZXF1aXJlZFwiKTtcblxuICAgICAgY29uc3QgZmVlZHNQYXJhbSA9IGZlZWRwdWJrZXlzLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIGF3YWl0IGF4aW9zXG4gICAgICAgIC5nZXQoYCR7dGhpcy5jcm9zc2JhclVybH0vc2ltdWxhdGUvc29sYW5hLyR7bmV0d29ya30vJHtmZWVkc1BhcmFtfWApXG4gICAgICAgIC50aGVuKChyZXNwKSA9PiByZXNwLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFheGlvcy5pc0F4aW9zRXJyb3IoZXJyKSkgdGhyb3cgZXJyO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGVyci5yZXNwb25zZTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHRocm93IGVycjtcblxuICAgICAgaWYgKHRoaXMudmVyYm9zZSkgY29uc29sZS5lcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLmRhdGF9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBCYWQgQ3Jvc3NiYXIgc2ltdWxhdGVTb2xhbmFGZWVkcyByZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR0VUIC91cGRhdGVzL2V2bS86Y2hhaW5JZC86YWdncmVnYXRvcklkc1xuICAgKiBGZXRjaCB1cGRhdGVzIGZvciBFVk0gbmV0d29yayBmZWVkcyBmcm9tIHRoZSBjcm9zc2JhclxuICAgKiBAcGFyYW0gcGFyYW0wIC0gVGhlIGNoYWluIElEIGFuZCBhZ2dyZWdhdG9yIElEcyB0byBmZXRjaCB1cGRhdGVzIGZvclxuICAgKiBAcmV0dXJucyBQcm9taXNlPHsgcmVzdWx0czogRVZNUmVzdWx0W107IGVuY29kZWQ6IHN0cmluZ1tdIH0+IC0gVGhlIHVwZGF0ZXMgZm9yIHRoZSBzcGVjaWZpZWQgZmVlZHNcbiAgICovXG4gIGFzeW5jIGZldGNoRVZNUmVzdWx0cyh7XG4gICAgY2hhaW5JZCxcbiAgICBhZ2dyZWdhdG9ySWRzLFxuICB9OiB7XG4gICAgY2hhaW5JZDogbnVtYmVyO1xuICAgIGFnZ3JlZ2F0b3JJZHM6IHN0cmluZ1tdO1xuICB9KTogUHJvbWlzZTx7IHJlc3VsdHM6IEVWTVJlc3VsdFtdOyBlbmNvZGVkOiBzdHJpbmdbXSB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghY2hhaW5JZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2hhaW4gSUQgaXMgcmVxdWlyZWRcIik7XG4gICAgICBpZiAoIWFnZ3JlZ2F0b3JJZHMgfHwgYWdncmVnYXRvcklkcy5sZW5ndGggPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBmZWVkIGlzIHJlcXVpcmVkXCIpO1xuXG4gICAgICBjb25zdCBmZWVkc1BhcmFtID0gYWdncmVnYXRvcklkcy5qb2luKFwiLFwiKTtcbiAgICAgIHJldHVybiBhd2FpdCBheGlvc1xuICAgICAgICAuZ2V0KGAke3RoaXMuY3Jvc3NiYXJVcmx9L3VwZGF0ZXMvZXZtLyR7Y2hhaW5JZH0vJHtmZWVkc1BhcmFtfWApXG4gICAgICAgIC50aGVuKChyZXNwKSA9PiByZXNwLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFheGlvcy5pc0F4aW9zRXJyb3IoZXJyKSkgdGhyb3cgZXJyO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGVyci5yZXNwb25zZTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHRocm93IGVycjtcblxuICAgICAgaWYgKHRoaXMudmVyYm9zZSkgY29uc29sZS5lcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLmRhdGF9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBCYWQgQ3Jvc3NiYXIgZmV0Y2hFVk1VcGRhdGVzIHJlc3BvbnNlOiAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHRVQgL3NpbXVsYXRlL2V2bS86bmV0d29yay86YWdncmVnYXRvcklkc1xuICAgKiBTaW11bGF0ZSBmZXRjaGluZyBTb2xhbmEgZmVlZCByZXN1bHRzIGZyb20gdGhlIGNyb3NzYmFyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gVGhlIFNvbGFuYSBuZXR3b3JrIHRvIHNpbXVsYXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGFnZ3JlZ2F0b3JJZHMgLSBUaGUgcHVibGljIGtleXMgb2YgdGhlIGZlZWRzIHRvIHNpbXVsYXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgZmVlZDogc3RyaW5nOyBmZWVkSGFzaDogc3RyaW5nOyByZXN1bHRzOiBudW1iZXJbXSB9W10+fSAtIFRoZSBzaW11bGF0ZWQgZmVlZCByZXN1bHRzXG4gICAqL1xuICBhc3luYyBzaW11bGF0ZUVWTUZlZWRzKFxuICAgIG5ldHdvcms6IG51bWJlcixcbiAgICBhZ2dyZWdhdG9ySWRzOiBzdHJpbmdbXVxuICApOiBQcm9taXNlPHsgYWdncmVnYXRvcklkOiBzdHJpbmc7IGZlZWRIYXNoOiBzdHJpbmc7IHJlc3VsdHM6IG51bWJlcltdIH1bXT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW5ldHdvcmspIHRocm93IG5ldyBFcnJvcihcIk5ldHdvcmsgaXMgcmVxdWlyZWRcIik7XG4gICAgICBpZiAoIWFnZ3JlZ2F0b3JJZHMgfHwgYWdncmVnYXRvcklkcy5sZW5ndGggPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBmZWVkIGlzIHJlcXVpcmVkXCIpO1xuXG4gICAgICBjb25zdCBmZWVkc1BhcmFtID0gYWdncmVnYXRvcklkcy5qb2luKFwiLFwiKTtcbiAgICAgIHJldHVybiBhd2FpdCBheGlvc1xuICAgICAgICAuZ2V0KGAke3RoaXMuY3Jvc3NiYXJVcmx9L3NpbXVsYXRlL2V2bS8ke25ldHdvcmt9LyR7ZmVlZHNQYXJhbX1gKVxuICAgICAgICAudGhlbigocmVzcCkgPT4gcmVzcC5kYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghYXhpb3MuaXNBeGlvc0Vycm9yKGVycikpIHRocm93IGVycjtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBlcnIucmVzcG9uc2U7XG4gICAgICBpZiAoIXJlc3BvbnNlKSB0aHJvdyBlcnI7XG5cbiAgICAgIGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUuZXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5kYXRhfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQmFkIENyb3NzYmFyIHNpbXVsYXRlRVZNRmVlZHMgcmVzcG9uc2U6ICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdFVCAvcmFuZG9tbmVzcy9ldm0vOmNoYWluSWQvOnJhbmRvbW5lc3NJZFxuICAgKiBAcGFyYW0gcGFyYW0wIC0gVGhlIGNoYWluIElEIGFuZCByYW5kb21uZXNzIElEIHRvIHJlc29sdmVcbiAgICovXG4gIGFzeW5jIHJlc29sdmVFVk1SYW5kb21uZXNzKHtcbiAgICBjaGFpbklkLFxuICAgIHJhbmRvbW5lc3NJZCxcbiAgfToge1xuICAgIGNoYWluSWQ6IG51bWJlcjtcbiAgICByYW5kb21uZXNzSWQ6IHN0cmluZztcbiAgfSk6IFByb21pc2U8e1xuICAgIGVuY29kZWQ6IHN0cmluZztcbiAgICByZXNwb25zZToge1xuICAgICAgc2lnbmF0dXJlOiBzdHJpbmc7XG4gICAgICByZWNvdmVyeV9pZDogbnVtYmVyO1xuICAgICAgdmFsdWU6IHN0cmluZztcbiAgICB9O1xuICB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBheGlvc1xuICAgICAgICAuZ2V0KGAke3RoaXMuY3Jvc3NiYXJVcmx9L3JhbmRvbW5lc3MvZXZtLyR7Y2hhaW5JZH0vJHtyYW5kb21uZXNzSWR9YClcbiAgICAgICAgLnRoZW4oKHJlc3ApID0+IHJlc3AuZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWF4aW9zLmlzQXhpb3NFcnJvcihlcnIpKSB0aHJvdyBlcnI7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyLnJlc3BvbnNlO1xuICAgICAgaWYgKCFyZXNwb25zZSkgdGhyb3cgZXJyO1xuXG4gICAgICBpZiAodGhpcy52ZXJib3NlKSBjb25zb2xlLmVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2UuZGF0YX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEJhZCBDcm9zc2JhciByZXNvbHZlRVZNUmFuZG9tbmVzcyByZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==