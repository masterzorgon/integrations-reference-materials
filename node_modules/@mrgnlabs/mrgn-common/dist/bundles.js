"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.simulateBundle = simulateBundle;
async function simulateBundle(rpcEndpoint, transactions, includeAccounts) {
    if (transactions.length === 0) {
        throw new Error("Empty bundle");
    }
    const encodedTransactions = transactions.map((tx) => {
        const serialized = tx.serialize();
        return Buffer.from(serialized).toString("base64");
    });
    const preExecutionAccountsConfigs = transactions.map(() => ({ addresses: [] }));
    let postExecutionAccountsConfigs = transactions.map((_, index) => {
        if (index === transactions.length - 1) {
            return {
                addresses: includeAccounts ? includeAccounts.map((account) => account.toBase58()) : []
            };
        }
        else {
            return ({ addresses: [] });
        }
    });
    const config = {
        skipSigVerify: true,
        replaceRecentBlockhash: true,
        preExecutionAccountsConfigs,
        postExecutionAccountsConfigs,
    };
    const responseRaw = await fetch(rpcEndpoint, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            jsonrpc: "2.0",
            id: 1,
            method: "simulateBundle",
            params: [{ encodedTransactions }, config],
        }),
    });
    const response = await responseRaw.json();
    if ("error" in response) {
        throw new Error(response.error.message);
    }
    const context = response.result.context;
    const value = response.result.value;
    const err = value.summary !== "succeeded" ? JSON.stringify(value.summary.failed.error) : null;
    return {
        context,
        value: {
            err,
            logs: value.transactionResults.flatMap((tx) => tx.logs),
            accounts: value.transactionResults[value.transactionResults.length - 1].postExecutionAccounts,
        },
    };
}
