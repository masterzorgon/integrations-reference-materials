"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarginfiAccountWrapper = void 0;
exports.makeBundleTipIx = makeBundleTipIx;
const mrgn_common_1 = require("@mrgnlabs/mrgn-common");
const sb = __importStar(require("@switchboard-xyz/on-demand"));
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const __1 = require("../..");
const types_1 = require("../../types");
const pure_1 = require("./pure");
const bank_1 = require("../bank");
const vendor_1 = require("../../vendor");
class MarginfiAccountWrapper {
    // --------------------------------------------------------------------------
    // Factories
    // --------------------------------------------------------------------------
    /**
     * @internal
     */
    constructor(marginfiAccountPk, client, marginfiAccount) {
        this.client = client;
        this.address = marginfiAccountPk;
        this._marginfiAccount = marginfiAccount;
    }
    static async fetch(marginfiAccountPk, client, commitment) {
        const { config, program } = client;
        const _marginfiAccountPk = (0, anchor_1.translateAddress)(marginfiAccountPk);
        const accountData = await MarginfiAccountWrapper._fetchAccountData(_marginfiAccountPk, config, program, commitment);
        const marginfiAccount = new pure_1.MarginfiAccount(_marginfiAccountPk, accountData);
        const marginfiAccountProxy = new MarginfiAccountWrapper(_marginfiAccountPk, client, marginfiAccount);
        require("debug")("mfi:margin-account")("Loaded marginfi account %s", _marginfiAccountPk);
        return marginfiAccountProxy;
    }
    static fromAccountParsed(marginfiAccountPk, client, accountData) {
        if (!accountData.group.equals(client.config.groupPk))
            throw Error(`Marginfi account tied to group ${accountData.group.toBase58()}. Expected: ${client.config.groupPk.toBase58()}`);
        const _marginfiAccountPk = (0, anchor_1.translateAddress)(marginfiAccountPk);
        const marginfiAccount = new pure_1.MarginfiAccount(_marginfiAccountPk, accountData);
        return new MarginfiAccountWrapper(_marginfiAccountPk, client, marginfiAccount);
    }
    static fromAccountDataRaw(marginfiAccountPk, client, marginfiAccountRawData, idl) {
        const marginfiAccountData = pure_1.MarginfiAccount.decode(marginfiAccountRawData, idl);
        return MarginfiAccountWrapper.fromAccountParsed(marginfiAccountPk, client, marginfiAccountData);
    }
    // --------------------------------------------------------------------------
    // Attributes
    // --------------------------------------------------------------------------
    get authority() {
        return this._marginfiAccount.authority;
    }
    get group() {
        return this.client.group;
    }
    get balances() {
        return this._marginfiAccount.balances;
    }
    get data() {
        return this._marginfiAccount;
    }
    get pureAccount() {
        return this._marginfiAccount;
    }
    /** @internal */
    get _program() {
        return this.client.program;
    }
    /** @internal */
    get _config() {
        return this.client.config;
    }
    get activeBalances() {
        return this._marginfiAccount.balances.filter((la) => la.active);
    }
    get isDisabled() {
        return this._marginfiAccount.isDisabled;
    }
    get isFlashLoanEnabled() {
        return this._marginfiAccount.isFlashLoanEnabled;
    }
    get isTransferAccountAuthorityEnabled() {
        return this._marginfiAccount.isTransferAccountAuthorityEnabled;
    }
    getBalance(bankPk) {
        return this._marginfiAccount.getBalance(bankPk);
    }
    canBeLiquidated() {
        const debugLogger = require("debug")(`mfi:margin-account:${this.address.toString()}:canBeLiquidated`);
        const { assets, liabilities } = this._marginfiAccount.computeHealthComponents(this.client.banks, this.client.oraclePrices, pure_1.MarginRequirementType.Maintenance);
        debugLogger("Account %s, maint assets: %s, maint liabilities: %s, maint healt: %s", this.address, assets, liabilities);
        return assets.lt(liabilities);
    }
    computeHealthComponents(marginRequirement, excludedBanks = []) {
        return this._marginfiAccount.computeHealthComponents(this.client.banks, this.client.oraclePrices, marginRequirement, excludedBanks);
    }
    computeFreeCollateral(opts) {
        return this._marginfiAccount.computeFreeCollateral(this.client.banks, this.client.oraclePrices, opts);
    }
    computeHealthComponentsWithoutBias(marginRequirement) {
        return this._marginfiAccount.computeHealthComponentsWithoutBias(this.client.banks, this.client.oraclePrices, marginRequirement);
    }
    computeAccountValue() {
        return this._marginfiAccount.computeAccountValue(this.client.banks, this.client.oraclePrices);
    }
    computeMaxBorrowForBank(bankAddress, opts) {
        return this._marginfiAccount.computeMaxBorrowForBank(this.client.banks, this.client.oraclePrices, bankAddress, opts);
    }
    computeMaxWithdrawForBank(bankAddress, opts) {
        return this._marginfiAccount.computeMaxWithdrawForBank(this.client.banks, this.client.oraclePrices, bankAddress, opts);
    }
    computeMaxLiquidatableAssetAmount(assetBankAddress, liabilityBankAddress) {
        return this._marginfiAccount.computeMaxLiquidatableAssetAmount(this.client.banks, this.client.oraclePrices, assetBankAddress, liabilityBankAddress);
    }
    computeLiquidationPriceForBank(bankAddress) {
        return this._marginfiAccount.computeLiquidationPriceForBank(this.client.banks, this.client.oraclePrices, bankAddress);
    }
    computeLiquidationPriceForBankAmount(bankAddress, isLending, amount) {
        return this._marginfiAccount.computeLiquidationPriceForBankAmount(this.client.banks, this.client.oraclePrices, bankAddress, isLending, amount);
    }
    computeNetApy() {
        return this._marginfiAccount.computeNetApy(this.client.banks, this.client.oraclePrices);
    }
    computeLoopingParams(principal, targetLeverage, depositBankAddress, borrowBankAddress) {
        const depositBank = this.client.banks.get(depositBankAddress.toBase58());
        if (!depositBank)
            throw Error(`Bank ${depositBankAddress.toBase58()} not found`);
        const depositPriceInfo = this.client.oraclePrices.get(depositBankAddress.toBase58());
        if (!depositPriceInfo)
            throw Error(`Price info for ${depositBankAddress.toBase58()} not found`);
        const borrowBank = this.client.banks.get(borrowBankAddress.toBase58());
        if (!borrowBank)
            throw Error(`Bank ${borrowBankAddress.toBase58()} not found`);
        const borrowPriceInfo = this.client.oraclePrices.get(borrowBankAddress.toBase58());
        if (!borrowPriceInfo)
            throw Error(`Price info for ${borrowBankAddress.toBase58()} not found`);
        return (0, bank_1.computeLoopingParams)(principal, targetLeverage, depositBank, borrowBank, depositPriceInfo, borrowPriceInfo);
    }
    makePriorityFeeIx(priorityFeeUi) {
        const priorityFeeIx = [];
        const limitCU = 1_400_000;
        let microLamports = 1;
        if (priorityFeeUi) {
            // if priority fee is above 0.2 SOL discard it for safety reasons
            const isAbsurdPriorityFee = priorityFeeUi > 0.2;
            if (!isAbsurdPriorityFee) {
                const priorityFeeMicroLamports = priorityFeeUi * web3_js_1.LAMPORTS_PER_SOL * 1_000_000;
                microLamports = Math.round(priorityFeeMicroLamports / limitCU);
            }
        }
        priorityFeeIx.push(web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
            microLamports,
        }));
        return priorityFeeIx;
    }
    makeComputeBudgetIx() {
        // Add additional CU request if necessary
        let cuRequestIxs = [];
        const activeBalances = this.balances.filter((b) => b.active);
        if (activeBalances.length >= 4) {
            cuRequestIxs.push(web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }));
        }
        return cuRequestIxs;
    }
    // --------------------------------------------------------------------------
    // User actions
    // --------------------------------------------------------------------------
    async makeSetupIx(banks) {
        this._marginfiAccount.authority;
        if (this.client.bankMetadataMap === undefined) {
            return [];
        }
        try {
            const userAtas = banks.map((bankAddress) => {
                const bank = this.client.bankMetadataMap[bankAddress.toBase58()];
                const mintData = this.client.mintDatas.get(bankAddress.toBase58());
                if (!mintData)
                    throw Error(`Token data for ${bank.tokenAddress} not found`);
                return (0, mrgn_common_1.getAssociatedTokenAddressSync)(new web3_js_1.PublicKey(bank.tokenAddress), this.authority, true, mintData.tokenProgram.equals(mrgn_common_1.TOKEN_2022_PROGRAM_ID) ? mrgn_common_1.TOKEN_2022_PROGRAM_ID : undefined);
            });
            let ixs = [];
            const userAtaAis = await this._program.provider.connection.getMultipleAccountsInfo(userAtas);
            for (const [i, userAta] of userAtaAis.entries()) {
                if (userAta === null) {
                    const bankAddress = banks[i];
                    const bank = this.client.bankMetadataMap[bankAddress.toBase58()];
                    const mintData = this.client.mintDatas.get(bankAddress.toBase58());
                    if (!mintData)
                        throw Error(`Token data for ${bank.tokenAddress} not found`);
                    ixs.push((0, mrgn_common_1.createAssociatedTokenAccountIdempotentInstruction)(this.authority, userAtas[i], this.authority, new web3_js_1.PublicKey(bank.tokenAddress), mintData.tokenProgram.equals(mrgn_common_1.TOKEN_2022_PROGRAM_ID) ? mrgn_common_1.TOKEN_2022_PROGRAM_ID : undefined));
                }
            }
            return ixs;
        }
        catch {
            return [];
        }
    }
    async repayWithCollat(repayAmount, withdrawAmount, borrowBankAddress, depositBankAddress, withdrawAll = false, repayAll = false, swapIxs, swapLookupTables, priorityFeeUi) {
        const debug = require("debug")(`mfi:margin-account:${this.address.toString()}:repay`);
        debug("Repaying %s into marginfi account (bank: %s), repay all: %s", repayAmount, borrowBankAddress, repayAll);
        const { flashloanTx, feedCrankTxs } = await this.makeRepayWithCollatTx(repayAmount, withdrawAmount, borrowBankAddress, depositBankAddress, withdrawAll, repayAll, swapIxs, swapLookupTables, priorityFeeUi);
        // assumes only one tx
        const sigs = await this.client.processTransactions([flashloanTx, ...feedCrankTxs]);
        debug("Repay with collateral successful %s", sigs.pop() ?? "");
        return sigs;
    }
    async simulateRepayWithCollat(repayAmount, withdrawAmount, borrowBankAddress, depositBankAddress, withdrawAll = false, repayAll = false, swapIxs, addressLookupTableAccounts) {
        const { flashloanTx } = await this.makeRepayWithCollatTx(repayAmount, withdrawAmount, borrowBankAddress, depositBankAddress, withdrawAll, repayAll, swapIxs, addressLookupTableAccounts);
        const [mfiAccountData, bankData] = await this.client.simulateTransactions([flashloanTx], [this.address, borrowBankAddress]);
        if (!mfiAccountData || !bankData)
            throw new Error("Failed to simulate repay w/ collat");
        const previewBanks = this.client.banks;
        previewBanks.set(borrowBankAddress.toBase58(), bank_1.Bank.fromBuffer(borrowBankAddress, bankData, this._program.idl, this.client.feedIdMap));
        const previewClient = new __1.MarginfiClient(this._config, this.client.program, {}, true, this.client.group, this.client.banks, this.client.oraclePrices, this.client.mintDatas, this.client.feedIdMap);
        const previewMarginfiAccount = MarginfiAccountWrapper.fromAccountDataRaw(this.address, previewClient, mfiAccountData, this._program.idl);
        return {
            banks: previewBanks,
            marginfiAccount: previewMarginfiAccount,
        };
    }
    async makeRepayWithCollatTx(repayAmount, withdrawAmount, borrowBankAddress, depositBankAddress, withdrawAll = false, repayAll = false, swapIxs, swapLookupTables, priorityFeeUi, isTxnSplitParam) {
        const setupIxs = await this.makeSetupIx([borrowBankAddress, depositBankAddress]);
        const cuRequestIxs = this.makeComputeBudgetIx();
        const priorityFeeIx = this.makePriorityFeeIx(priorityFeeUi);
        const withdrawIxs = await this.makeWithdrawIx(withdrawAmount, depositBankAddress, withdrawAll, {
            createAtas: false,
            wrapAndUnwrapSol: false,
        });
        const depositIxs = await this.makeRepayIx(repayAmount, borrowBankAddress, repayAll, {
            createAtas: false,
            wrapAndUnwrapSol: false,
        });
        const bundleTipIx = makeBundleTipIx(this.client.provider.publicKey);
        const lookupTables = this.client.addressLookupTables;
        const { instructions: updateFeedIxs, luts: feedLuts } = await this.makeUpdateFeedIx([
            depositBankAddress,
            borrowBankAddress,
        ]);
        const addressLookupTableAccounts = [...lookupTables, ...swapLookupTables];
        let feedCrankTxs = [];
        // isTxnSplit forced set to true as we're always splitting now
        const isTxnSplit = true; //isTxnSplitParam
        if (isTxnSplit) {
            const { blockhash } = await this._program.provider.connection.getLatestBlockhash();
            const message = new web3_js_1.TransactionMessage({
                payerKey: this.client.wallet.publicKey,
                recentBlockhash: blockhash,
                instructions: [bundleTipIx, ...updateFeedIxs],
            }).compileToV0Message([...addressLookupTableAccounts, ...feedLuts]);
            feedCrankTxs = [new web3_js_1.VersionedTransaction(message)];
        }
        const flashloanTx = await this.buildFlashLoanTx({
            ixs: [
                ...priorityFeeIx,
                ...cuRequestIxs,
                ...(isTxnSplit ? [] : [bundleTipIx]),
                ...setupIxs,
                ...withdrawIxs.instructions,
                ...swapIxs,
                ...depositIxs.instructions,
            ],
            addressLookupTableAccounts,
        });
        return { flashloanTx, feedCrankTxs, addressLookupTableAccounts };
    }
    async loop(depositAmount, borrowAmount, depositBankAddress, borrowBankAddress, swapIxs, swapLookupTables, priorityFeeUi) {
        const depositBank = this.client.banks.get(depositBankAddress.toBase58());
        if (!depositBank)
            throw Error("Deposit bank not found");
        const borrowBank = this.client.banks.get(borrowBankAddress.toBase58());
        if (!borrowBank)
            throw Error("Borrow bank not found");
        const debug = require("debug")(`mfi:margin-account:${this.address.toString()}:repay`);
        debug(`Looping ${depositAmount} ${depositBank.tokenSymbol} against ${borrowAmount} ${borrowBank.tokenSymbol} into marginfi account (banks: ${depositBankAddress.toBase58()} / ${borrowBankAddress.toBase58()})`);
        const { flashloanTx, feedCrankTxs } = await this.makeLoopTx(depositAmount, borrowAmount, depositBankAddress, borrowBankAddress, swapIxs, swapLookupTables, priorityFeeUi);
        // TODO: Check why different than repayWithCollat
        const sig = await this.client.processTransaction(flashloanTx, []);
        debug("Repay with collateral successful %s", sig);
        return sig;
    }
    async simulateLoop(depositAmount, borrowAmount, depositBankAddress, borrowBankAddress, swapIxs, swapLookupTables, priorityFeeUi) {
        const { flashloanTx } = await this.makeLoopTx(depositAmount, borrowAmount, depositBankAddress, borrowBankAddress, swapIxs, swapLookupTables, priorityFeeUi);
        const [mfiAccountData, depositBankData, borrowBankData] = await this.client.simulateTransactions([flashloanTx], [this.address, depositBankAddress, borrowBankAddress]);
        if (!mfiAccountData || !depositBankData || !borrowBankData)
            throw new Error("Failed to simulate repay w/ collat");
        const previewBanks = this.client.banks;
        previewBanks.set(depositBankAddress.toBase58(), bank_1.Bank.fromBuffer(depositBankAddress, depositBankData, this._program.idl, this.client.feedIdMap));
        previewBanks.set(borrowBankAddress.toBase58(), bank_1.Bank.fromBuffer(borrowBankAddress, borrowBankData, this._program.idl, this.client.feedIdMap));
        const previewClient = new __1.MarginfiClient(this._config, this.client.program, {}, true, this.client.group, this.client.banks, this.client.oraclePrices, this.client.mintDatas, this.client.feedIdMap);
        const previewMarginfiAccount = MarginfiAccountWrapper.fromAccountDataRaw(this.address, previewClient, mfiAccountData, this._program.idl);
        return {
            banks: previewBanks,
            marginfiAccount: previewMarginfiAccount,
        };
    }
    async makeLoopTx(depositAmount, borrowAmount, depositBankAddress, borrowBankAddress, swapIxs, swapLookupTables, priorityFeeUi, createAtas
    // isTxnSplitParam?: boolean
    ) {
        const depositBank = this.client.banks.get(depositBankAddress.toBase58());
        if (!depositBank)
            throw Error("Deposit bank not found");
        const borrowBank = this.client.banks.get(borrowBankAddress.toBase58());
        if (!borrowBank)
            throw Error("Borrow bank not found");
        const setupIxs = createAtas ? await this.makeSetupIx([depositBankAddress, borrowBankAddress]) : [];
        const cuRequestIxs = this.makeComputeBudgetIx();
        const priorityFeeIx = this.makePriorityFeeIx(priorityFeeUi);
        const borrowIxs = await this.makeBorrowIx(borrowAmount, borrowBankAddress, {
            createAtas: true,
            wrapAndUnwrapSol: false,
        });
        const depositIxs = await this.makeDepositIx(depositAmount, depositBankAddress, {
            wrapAndUnwrapSol: true,
        });
        const bundleTipIx = makeBundleTipIx(this.client.provider.publicKey);
        const clientLookupTables = this.client.addressLookupTables;
        const { instructions: updateFeedIxs, luts: feedLuts } = await this.makeUpdateFeedIx([
            depositBankAddress,
            borrowBankAddress,
        ]);
        // isTxnSplit forced set to true as we're always splitting now
        const { blockhash } = await this._program.provider.connection.getLatestBlockhash();
        const message = new web3_js_1.TransactionMessage({
            payerKey: this.client.wallet.publicKey,
            recentBlockhash: blockhash,
            instructions: [bundleTipIx, ...updateFeedIxs, ...setupIxs],
        }).compileToV0Message([...clientLookupTables, ...feedLuts]);
        const feedCrankTxs = [new web3_js_1.VersionedTransaction(message)];
        const flashloanTx = await this.buildFlashLoanTx({
            ixs: [...priorityFeeIx, ...cuRequestIxs, ...borrowIxs.instructions, ...swapIxs, ...depositIxs.instructions],
            addressLookupTableAccounts: [...clientLookupTables, ...swapLookupTables],
        });
        return {
            flashloanTx,
            feedCrankTxs,
            addressLookupTableAccounts: [...clientLookupTables, ...swapLookupTables, ...feedLuts],
        };
    }
    async makeDepositIx(amount, bankAddress, opt = {}) {
        return this._marginfiAccount.makeDepositIx(this._program, this.client.banks, this.client.mintDatas, amount, bankAddress, opt);
    }
    async deposit(amount, bankAddress, opt = {}) {
        const debug = require("debug")(`mfi:margin-account:${this.address.toString()}:deposit`);
        debug("Depositing %s into marginfi account (bank: %s)", amount, (0, mrgn_common_1.shortenAddress)(bankAddress));
        const priorityFeeIx = this.makePriorityFeeIx(opt.priorityFeeUi);
        const bundleTipIx = makeBundleTipIx(this.client.provider.publicKey);
        const ixs = await this.makeDepositIx(amount, bankAddress, opt);
        const tx = new web3_js_1.Transaction().add(bundleTipIx, ...priorityFeeIx, ...ixs.instructions);
        const sig = await this.client.processTransaction(tx, []);
        debug("Depositing successful %s", sig);
        return sig;
    }
    async simulateDeposit(amount, bankAddress) {
        const ixs = await this.makeDepositIx(amount, bankAddress);
        const tx = new web3_js_1.Transaction().add(...ixs.instructions);
        const [mfiAccountData, bankData] = await this.client.simulateTransactions([tx], [this.address, bankAddress]);
        if (!mfiAccountData || !bankData)
            throw new Error("Failed to simulate deposit");
        const previewBanks = this.client.banks;
        previewBanks.set(bankAddress.toBase58(), bank_1.Bank.fromBuffer(bankAddress, bankData, this._program.idl, this.client.feedIdMap));
        const previewClient = new __1.MarginfiClient(this._config, this.client.program, {}, true, this.client.group, this.client.banks, this.client.oraclePrices, this.client.mintDatas, this.client.feedIdMap);
        const previewMarginfiAccount = MarginfiAccountWrapper.fromAccountDataRaw(this.address, previewClient, mfiAccountData, this._program.idl);
        return {
            banks: previewBanks,
            marginfiAccount: previewMarginfiAccount,
        };
    }
    async makeRepayIx(amount, bankAddress, repayAll = false, opt = {}) {
        const tokenProgramAddress = this.client.mintDatas.get(bankAddress.toBase58())?.tokenProgram;
        if (!tokenProgramAddress)
            throw Error("Repay mint not found");
        return this._marginfiAccount.makeRepayIx(this._program, this.client.banks, this.client.mintDatas, amount, bankAddress, repayAll, opt);
    }
    async repay(amount, bankAddress, repayAll = false, opt = {}) {
        const debug = require("debug")(`mfi:margin-account:${this.address.toString()}:repay`);
        debug("Repaying %s into marginfi account (bank: %s), repay all: %s", amount, bankAddress, repayAll);
        const priorityFeeIx = this.makePriorityFeeIx(opt.priorityFeeUi);
        const bundleTipIx = makeBundleTipIx(this.client.provider.publicKey);
        const ixs = await this.makeRepayIx(amount, bankAddress, repayAll, opt);
        const tx = new web3_js_1.Transaction().add(bundleTipIx, ...priorityFeeIx, ...ixs.instructions);
        const sig = await this.client.processTransaction(tx, []);
        debug("Depositing successful %s", sig);
        return sig;
    }
    async simulateRepay(amount, bankAddress, repayAll = false) {
        const ixs = await this.makeRepayIx(amount, bankAddress, repayAll);
        const tx = new web3_js_1.Transaction().add(...ixs.instructions);
        const [mfiAccountData, bankData] = await this.client.simulateTransactions([tx], [this.address, bankAddress]);
        if (!mfiAccountData || !bankData)
            throw new Error("Failed to simulate repay");
        const previewBanks = this.client.banks;
        previewBanks.set(bankAddress.toBase58(), bank_1.Bank.fromBuffer(bankAddress, bankData, this._program.idl, this.client.feedIdMap));
        const previewClient = new __1.MarginfiClient(this._config, this.client.program, {}, true, this.client.group, this.client.banks, this.client.oraclePrices, this.client.mintDatas, this.client.feedIdMap);
        const previewMarginfiAccount = MarginfiAccountWrapper.fromAccountDataRaw(this.address, previewClient, mfiAccountData, this._program.idl);
        return {
            banks: previewBanks,
            marginfiAccount: previewMarginfiAccount,
        };
    }
    async makeWithdrawIx(amount, bankAddress, withdrawAll = false, opt = {}) {
        const tokenProgramAddress = this.client.mintDatas.get(bankAddress.toBase58())?.tokenProgram;
        if (!tokenProgramAddress)
            throw Error("Withdraw mint not found");
        return this._marginfiAccount.makeWithdrawIx(this._program, this.client.banks, this.client.mintDatas, amount, bankAddress, withdrawAll, opt);
    }
    async makeWithdrawAllTx(banks, opt = {}) {
        const debug = require("debug")(`mfi:margin-account:${this.address.toString()}:withdraw`);
        debug("Withdrawing all from marginfi account");
        const priorityFeeIx = this.makePriorityFeeIx(opt.priorityFeeUi);
        const cuRequestIxs = this.makeComputeBudgetIx();
        let ixs = [];
        for (const bank of banks) {
            ixs.push(...(await this.makeWithdrawIx(bank.amount, bank.bankAddress, true, opt)).instructions);
        }
        const tx = new web3_js_1.Transaction().add(...priorityFeeIx, ...cuRequestIxs, ...ixs);
        return tx;
    }
    async withdraw(amount, bankAddress, withdrawAll = false, opt = {}) {
        const debug = require("debug")(`mfi:margin-account:${this.address.toString()}:withdraw`);
        debug("Withdrawing %s from marginfi account", amount);
        const { feedCrankTxs, withdrawTx } = await this.makeWithdrawTx(amount, bankAddress, withdrawAll, opt);
        // process multiple transactions if feed updates required
        const sigs = await this.client.processTransactions([...feedCrankTxs, withdrawTx]);
        debug("Withdrawing successful %s", sigs.pop());
        return sigs;
    }
    async makeWithdrawTx(amount, bankAddress, withdrawAll = false, opt = {}) {
        const bundleTipIx = makeBundleTipIx(this.client.provider.publicKey);
        const priorityFeeIxs = this.makePriorityFeeIx(opt.priorityFeeUi);
        const cuRequestIxs = this.makeComputeBudgetIx();
        const { instructions: updateFeedIxs, luts: feedLuts } = await this.makeUpdateFeedIx([]);
        const ixs = await this.makeWithdrawIx(amount, bankAddress, withdrawAll, opt);
        const { value: { blockhash }, } = await this._program.provider.connection.getLatestBlockhashAndContext();
        let feedCrankTxs = [];
        if (updateFeedIxs.length > 0) {
            feedCrankTxs.push(new web3_js_1.VersionedTransaction(new web3_js_1.TransactionMessage({
                instructions: updateFeedIxs,
                payerKey: this.authority,
                recentBlockhash: blockhash,
            }).compileToV0Message([...feedLuts])));
        }
        const withdrawTx = new web3_js_1.VersionedTransaction(new web3_js_1.TransactionMessage({
            instructions: [bundleTipIx, ...cuRequestIxs, ...priorityFeeIxs, ...ixs.instructions],
            payerKey: this.authority,
            recentBlockhash: blockhash,
        }).compileToV0Message([...this.client.addressLookupTables]));
        const addressLookupTableAccounts = [...this.client.addressLookupTables, ...feedLuts];
        return { feedCrankTxs, withdrawTx, addressLookupTableAccounts };
    }
    async simulateWithdraw(bankAddress, txs) {
        const [mfiAccountData, bankData] = await this.client.simulateTransactions(txs, [this.address, bankAddress]);
        if (!mfiAccountData || !bankData)
            throw new Error("Failed to simulate withdraw");
        const previewBanks = this.client.banks;
        previewBanks.set(bankAddress.toBase58(), bank_1.Bank.fromBuffer(bankAddress, bankData, this._program.idl, this.client.feedIdMap));
        const previewClient = new __1.MarginfiClient(this._config, this.client.program, {}, true, this.client.group, this.client.banks, this.client.oraclePrices, this.client.mintDatas, this.client.feedIdMap);
        const previewMarginfiAccount = MarginfiAccountWrapper.fromAccountDataRaw(this.address, previewClient, mfiAccountData, this._program.idl);
        return {
            banks: previewBanks,
            marginfiAccount: previewMarginfiAccount,
        };
    }
    async makeBorrowIx(amount, bankAddress, opt = {}) {
        const tokenProgramAddress = this.client.mintDatas.get(bankAddress.toBase58())?.tokenProgram;
        if (!tokenProgramAddress)
            throw Error("Borrow mint not found");
        return this._marginfiAccount.makeBorrowIx(this._program, this.client.banks, this.client.mintDatas, amount, bankAddress, opt);
    }
    async borrow(amount, bankAddress, opt = {}) {
        const debug = require("debug")(`mfi:margin-account:${this.address.toString()}:borrow`);
        debug("Borrowing %s from marginfi account", amount);
        const { feedCrankTxs, borrowTx } = await this.makeBorrowTx(amount, bankAddress, opt);
        // process multiple transactions if feed updates required
        const sigs = await this.client.processTransactions([...feedCrankTxs, borrowTx]);
        debug("Borrowing successful %s", sigs);
        return sigs;
    }
    async makeBorrowTx(amount, bankAddress, opt = {}) {
        const bundleTipIx = makeBundleTipIx(this.client.provider.publicKey);
        const priorityFeeIxs = this.makePriorityFeeIx(opt.priorityFeeUi);
        const cuRequestIxs = this.makeComputeBudgetIx();
        const { instructions: updateFeedIxs, luts: feedLuts } = await this.makeUpdateFeedIx([bankAddress]);
        const ixs = await this.makeBorrowIx(amount, bankAddress, opt);
        const { value: { blockhash }, } = await this._program.provider.connection.getLatestBlockhashAndContext();
        let feedCrankTxs = [];
        if (updateFeedIxs.length > 0) {
            feedCrankTxs.push(new web3_js_1.VersionedTransaction(new web3_js_1.TransactionMessage({
                instructions: updateFeedIxs,
                payerKey: this.authority,
                recentBlockhash: blockhash,
            }).compileToV0Message([...feedLuts])));
        }
        const borrowTx = new web3_js_1.VersionedTransaction(new web3_js_1.TransactionMessage({
            instructions: [bundleTipIx, ...cuRequestIxs, ...priorityFeeIxs, ...ixs.instructions],
            payerKey: this.authority,
            recentBlockhash: blockhash,
        }).compileToV0Message([...this.client.addressLookupTables]));
        const addressLookupTableAccounts = [...this.client.addressLookupTables, ...feedLuts];
        return { feedCrankTxs, borrowTx, addressLookupTableAccounts };
    }
    async simulateBorrow(bankAddress, transactions) {
        const [mfiAccountData, bankData] = await this.client.simulateTransactions(transactions, [
            this.address,
            bankAddress,
        ]);
        if (!mfiAccountData || !bankData)
            throw new Error("Failed to simulate borrow");
        const previewBanks = this.client.banks;
        previewBanks.set(bankAddress.toBase58(), bank_1.Bank.fromBuffer(bankAddress, bankData, this._program.idl, this.client.feedIdMap));
        const previewClient = new __1.MarginfiClient(this._config, this.client.program, {}, true, this.client.group, this.client.banks, this.client.oraclePrices, this.client.mintDatas, this.client.feedIdMap);
        const previewMarginfiAccount = MarginfiAccountWrapper.fromAccountDataRaw(this.address, previewClient, mfiAccountData, this._program.idl);
        return {
            banks: previewBanks,
            marginfiAccount: previewMarginfiAccount,
        };
    }
    async makeWithdrawEmissionsIx(bankAddress) {
        return this._marginfiAccount.makeWithdrawEmissionsIx(this._program, this.client.banks, this.client.mintDatas, bankAddress);
    }
    async withdrawEmissions(bankAddresses, priorityFeeUi) {
        const debug = require("debug")(`mfi:margin-account:${this.address.toString()}:withdraw-emissions`);
        debug("Withdrawing emission from marginfi account (bank: %s)", bankAddresses.map((b) => b.toBase58()).join(", "));
        const bundleTipIx = makeBundleTipIx(this.client.provider.publicKey);
        const priorityFeeIx = this.makePriorityFeeIx(priorityFeeUi);
        const ixs = [];
        const signers = [];
        for (const bankAddress of bankAddresses) {
            const ix = await this.makeWithdrawEmissionsIx(bankAddress);
            ixs.push(...ix.instructions);
            signers.push(ix.keys);
        }
        const tx = new web3_js_1.Transaction().add(bundleTipIx, ...priorityFeeIx, ...ixs);
        const sig = await this.client.processTransaction(tx, []);
        debug("Withdrawing emission successful %s", sig);
        return sig;
    }
    async makeLendingAccountLiquidateIx(liquidateeMarginfiAccount, assetBankAddress, assetQuantityUi, liabBankAddress) {
        const liabTokenProgramAddress = this.client.mintDatas.get(liabBankAddress.toBase58())?.tokenProgram;
        if (!liabTokenProgramAddress)
            throw Error("Liability mint not found");
        return this._marginfiAccount.makeLendingAccountLiquidateIx(liquidateeMarginfiAccount, this._program, this.client.banks, this.client.mintDatas, assetBankAddress, assetQuantityUi, liabBankAddress);
    }
    async lendingAccountLiquidate(liquidateeMarginfiAccount, assetBankAddress, assetQuantityUi, liabBankAddress) {
        const debug = require("debug")(`mfi:margin-account:${this.address.toString()}:liquidation`);
        debug("Liquidating marginfi account %s", liquidateeMarginfiAccount.address.toBase58());
        const ixw = await this.makeLendingAccountLiquidateIx(liquidateeMarginfiAccount, assetBankAddress, assetQuantityUi, liabBankAddress);
        const tx = new web3_js_1.Transaction().add(...ixw.instructions);
        const sig = await this.client.processTransaction(tx, []);
        debug("Liquidation successful %s", sig);
        return sig;
    }
    async makeBeginFlashLoanIx(endIndex) {
        return this._marginfiAccount.makeBeginFlashLoanIx(this._program, endIndex);
    }
    async makeEndFlashLoanIx(projectedActiveBalances) {
        return this._marginfiAccount.makeEndFlashLoanIx(this._program, this.client.banks, projectedActiveBalances);
    }
    async flashLoan(args) {
        const debug = require("debug")(`mfi:margin-account:${this.address.toString()}:flashLoan`);
        debug("Executing flashloan from marginfi account");
        const lookupTables = this.client.addressLookupTables;
        const tx = await this.buildFlashLoanTx(args, lookupTables);
        const sig = await this.client.processTransaction(tx, []);
        debug("Flashloan successful %s", sig);
        return sig;
    }
    async buildFlashLoanTx(args, lookupTables) {
        const endIndex = args.ixs.length + 1;
        const projectedActiveBalances = this._marginfiAccount.projectActiveBalancesNoCpi(this._program, args.ixs);
        const beginFlashLoanIx = await this.makeBeginFlashLoanIx(endIndex);
        const endFlashLoanIx = await this.makeEndFlashLoanIx(projectedActiveBalances);
        const ixs = [...beginFlashLoanIx.instructions, ...args.ixs, ...endFlashLoanIx.instructions];
        const { blockhash } = await this._program.provider.connection.getLatestBlockhash();
        const message = new web3_js_1.TransactionMessage({
            payerKey: this.client.wallet.publicKey,
            recentBlockhash: blockhash,
            instructions: ixs,
        }).compileToV0Message([...(lookupTables ?? []), ...(args.addressLookupTableAccounts ?? [])]);
        const tx = new web3_js_1.VersionedTransaction(message);
        if (args.signers) {
            tx.sign(args.signers);
        }
        return tx;
    }
    async makeTransferAccountAuthorityIx(newAccountAuthority) {
        return this._marginfiAccount.makeAccountAuthorityTransferIx(this._program, newAccountAuthority);
    }
    async transferAccountAuthority(newAccountAuthority) {
        const debug = require("debug")(`mfi:margin-account:${this.address.toString()}:transfer-authority`);
        debug("Transferring account %s to %s", this.address.toBase58(), newAccountAuthority.toBase58());
        const ixs = await this.makeTransferAccountAuthorityIx(newAccountAuthority);
        const tx = new web3_js_1.Transaction().add(...ixs.instructions);
        const sig = await this.client.processTransaction(tx, []);
        debug("Transfer successful %s", sig);
        return sig;
    }
    async makeUpdateFeedIx(newBanksPk, txLandingBuffer = 0) {
        // filter active and newly opening balances
        const activeBanksPk = this._marginfiAccount.balances
            .filter((balance) => balance.active)
            .map((balance) => balance.bankPk);
        const activeBanks = activeBanksPk.map((pk) => this.client.banks.get(pk.toBase58()));
        const newBanks = newBanksPk.map((pk) => this.client.banks.get(pk.toBase58()));
        const swbPullBanks = [...new Set([...activeBanks, ...newBanks]).values()].filter((bank) => bank.config.oracleSetup === __1.OracleSetup.SwitchboardPull);
        if (swbPullBanks.length > 0) {
            const staleOracles = swbPullBanks
                .filter((bank) => {
                const oraclePrice = this.client.oraclePrices.get(bank.address.toBase58());
                const maxAge = bank.config.oracleMaxAge;
                const currentTime = Math.round(Date.now() / 1000);
                const oracleTime = Math.round(oraclePrice?.timestamp ? oraclePrice.timestamp.toNumber() : new Date().getTime());
                const adjustedMaxAge = Math.max(maxAge - txLandingBuffer, 0);
                const isStale = currentTime - oracleTime > adjustedMaxAge;
                return isStale;
            })
                .map((bank) => bank.oracleKey);
            if (staleOracles.length > 0) {
                const sbProgram = (0, vendor_1.getSwitchboardProgram)(this._program.provider);
                const [pullIx, luts] = await sb.PullFeed.fetchUpdateManyIx(sbProgram, {
                    feeds: staleOracles,
                    numSignatures: 1,
                });
                const cuRequestIx = web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 });
                return { instructions: [cuRequestIx, pullIx], luts };
            }
            return { instructions: [], luts: [] };
        }
        else {
            return { instructions: [], luts: [] };
        }
    }
    // --------------------------------------------------------------------------
    // Helpers
    // --------------------------------------------------------------------------
    getHealthCheckAccounts(mandatoryBanks = [], excludedBanks = []) {
        return this._marginfiAccount.getHealthCheckAccounts(this.client.banks, mandatoryBanks, excludedBanks);
    }
    static async _fetchAccountData(accountAddress, config, program, commitment) {
        const mergedCommitment = commitment ?? program.provider.connection.commitment ?? mrgn_common_1.DEFAULT_COMMITMENT;
        const data = (await program.account.marginfiAccount.fetch(accountAddress, mergedCommitment));
        if (!data.group.equals(config.groupPk))
            throw Error(`Marginfi account tied to group ${data.group.toBase58()}. Expected: ${config.groupPk.toBase58()}`);
        return data;
    }
    static async encode(decoded, idl) {
        const coder = new anchor_1.BorshCoder(idl);
        return await coder.accounts.encode(types_1.AccountType.MarginfiAccount, decoded);
    }
    async reload() {
        require("debug")(`mfi:margin-account:${this.address.toBase58().toString()}:loader`)("Reloading account data");
        const marginfiAccountAi = await this._program.account.marginfiAccount.getAccountInfo(this.address);
        if (!marginfiAccountAi)
            throw new Error(`Failed to fetch data for marginfi account ${this.address.toBase58()}`);
        const marginfiAccountParsed = pure_1.MarginfiAccount.decode(marginfiAccountAi.data, this._program.idl);
        if (!marginfiAccountParsed.group.equals(this._config.groupPk))
            throw Error(`Marginfi account tied to group ${marginfiAccountParsed.group.toBase58()}. Expected: ${this._config.groupPk.toBase58()}`);
        this._updateFromAccountParsed(marginfiAccountParsed);
    }
    _updateFromAccountParsed(data) {
        this._marginfiAccount = new pure_1.MarginfiAccount(this.address, data);
    }
    describe() {
        return this._marginfiAccount.describe(this.client.banks, this.client.oraclePrices);
    }
}
exports.MarginfiAccountWrapper = MarginfiAccountWrapper;
function makeBundleTipIx(feePayer) {
    // they have remained constant so function not used (for now)
    const getTipAccounts = async () => {
        const response = await fetch("https://mainnet.block-engine.jito.wtf/api/v1/bundles", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                jsonrpc: "2.0",
                id: 1,
                method: "getTipAccounts",
                params: [],
            }),
        });
        const data = await response.json();
        return data.result;
    };
    const tipAccounts = [
        "96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5",
        "HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe",
        "Cw8CFyM9FkoMi7K7Crf6HNQqf4uEMzpKw6QNghXLvLkY",
        "ADaUMid9yfUytqMBgopwjb2DTLSokTSzL1zt6iGPaS49",
        "DfXygSm4jCyNCybVYYK6DwvWqjKee8pbDmJGcLWNDXjh",
        "ADuUkR4vqLUMWXxW9gh6D6L8pMSawimctcNZ5pGwDcEt",
        "DttWaMuVvTiduZRnguLF7jNxTgiMBZ1hyAumKUiL2KRL",
        "3AVi9Tg9Uo68tJfuvoKvqKNWKkC5wPdSSdeBnizKZ6jT",
    ];
    const randomTipAccount = tipAccounts[Math.floor(Math.random() * tipAccounts.length)];
    return web3_js_1.SystemProgram.transfer({
        fromPubkey: feePayer,
        toPubkey: new web3_js_1.PublicKey(randomTipAccount),
        lamports: 10_000, // 1000 lamports = 0.000001 SOL
    });
}
